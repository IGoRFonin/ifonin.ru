# Дизайн: скил blog-series

**Дата**: 2026-02-15
**Статус**: утверждён

## Проблема

Скил `blog-post` пишет одну самодостаточную статью. Для серии из N связных статей нужен:
- общий серийный контекст (терминология, что уже опубликовано)
- перекрёстные ссылки между статьями
- избежание повторов
- управление прогрессом

## Решение

Три скила в неймспейсе `blog-series:`, работающих как оркестратор поверх `blog-post`.

### Архитектура

```
blog-series:init  → создать серию (ресёрч, план, структура)
blog-series:next  → написать следующую статью (серийный бриф → blog-post)
blog-series:status → дашборд прогресса
```

Ключевой принцип: **blog-series владеет контекстом серии, blog-post владеет качеством текста**. blog-post не модифицируется — получает обогащённый бриф.

## Файловая структура

```
docs/series/
  registry.json                      # реестр всех серий
  <slug>/
    series.json                      # состояние, глоссарий, статьи со статусами и саммари
    index.md                         # человекочитаемый план серии
    research/
      article-01.md                  # ресёрч per article
      article-02.md
      ...
```

### registry.json

Глобальный реестр всех серий:

```json
{
  "series": [
    {
      "slug": "context-engineering",
      "title": "Оптимизация контекста в Claude Code",
      "created": "2026-02-15",
      "total": 12,
      "published": 0,
      "active": true
    }
  ]
}
```

### series.json

Состояние конкретной серии:

```json
{
  "slug": "context-engineering",
  "title": "Оптимизация контекста в Claude Code",
  "created": "2026-02-15",
  "glossary": {
    "compaction": "трёхслойная система сжатия контекста",
    "context window": "окно контекста — все токены, которые модель видит при генерации"
  },
  "publication_order": [1, 2, 12, 4, 7, 5, 3, 6, 10, 8, 9, 11],
  "articles": [
    {
      "number": 1,
      "slug": "context-engineering-intro",
      "title": "Context Engineering — новая парадигма",
      "complexity": "вводная",
      "status": "published",
      "date": "2026-02-17",
      "summary": "2-3 предложения о чём статья",
      "key_terms": ["context engineering", "prompt engineering"],
      "links_to": [2, 4],
      "links_from": []
    },
    {
      "number": 2,
      "slug": null,
      "title": "Как устроен контекст внутри",
      "complexity": "техническая",
      "status": "research_done",
      "date": null,
      "summary": null,
      "key_terms": [],
      "links_to": [],
      "links_from": []
    }
  ]
}
```

Статусы статьи: `planned` → `research_done` → `published`

## Скил blog-series:init

Создание новой серии.

### Входные данные
- Тема серии, целевая аудитория, примерное кол-во статей
- Опционально: уже готовые материалы (файлы/папка)

### Процесс

**Шаг 1: Сбор информации**
- Тема, аудитория, кол-во статей
- Вопрос: "У тебя уже есть материалы?"

**Шаг 2: Анализ входных данных**

Если материалы есть:
- Прочитать все предоставленные файлы
- Определить покрытие: какие темы, какие источники, уровень детализации
- Отчёт: "вот что есть, вот что нужно дособрать"
- **Human gate**: подтверждение что доисследовать

Если материалов нет:
- Параллельный ресёрч темы с нуля (субагенты)

**Шаг 3: Дополнительный ресёрч** (если нужен)
- Субагенты закрывают найденные пробелы

**Шаг 4: Структурирование серии**
- Разбивка на статьи: тема, ключевой тезис, сложность
- Порядок публикации
- Карта связей между статьями
- Глоссарий ключевых терминов
- **Human gate**: утверждение плана

**Шаг 5: Ресёрч per article**
- Для статей с готовым ресёрчем — принять как есть (или дополнить)
- Для остальных — параллельные субагенты
- **Human gate**: пользователь смотрит ресёрч

**Шаг 6: Сохранение**
- Создать `docs/series/<slug>/` со всеми файлами
- Записать в `registry.json`
- Коммит

### Выход
Серия в статусе ready, все статьи в `planned` или `research_done`.

## Скил blog-series:next

Написание следующей статьи серии.

### Процесс

**Шаг 1: Определить что писать**
- Прочитать `registry.json` → активная серия (или спросить если несколько)
- Прочитать `series.json` → первая не-`published` статья по `publication_order`
- Показать пользователю, дать возможность переопределить

**Шаг 2: Собрать серийный бриф**
Из `series.json`:
- Глоссарий терминов (чтобы не переопределять заново)
- Саммари опубликованных статей (2-3 предложения каждая)
- Карта ссылок: "в этой статье сослаться на статьи X, Y"
- Ключевые термины, которые уже введены в серии

Из `research/article-NN.md`:
- Ресёрч для конкретной статьи

**Шаг 3: Вызвать blog-post**
- Передать обогащённый контекст: тема + серийный бриф + ресёрч
- blog-post работает как обычно: plan → draft → critique → rewrite → deploy
- Пользователь участвует в human gates blog-post

**Шаг 4: Обновить состояние серии**
После деплоя:
- Статус статьи → `published`
- Записать саммари (сгенерировать из финального текста)
- Записать slug и дату публикации
- Обновить `links_from` у связанных статей
- Обновить глоссарий если появились новые термины
- Коммит `series.json`

## Скил blog-series:status

Дашборд прогресса. Только чтение, никаких мутаций.

### Вывод

```
Серии статей

▸ context-engineering (активна)
  "Оптимизация контекста в Claude Code"
  Прогресс: 2/12 опубликовано
  Следующая: #3 Compaction — трёхслойная система сжатия

  01 ✓ Context Engineering — новая парадигма     (17 фев)
  02 ✓ Как устроен контекст внутри               (18 фев)
  03 ○ Compaction                                 ← следующая
  04 ○ CLAUDE.md — персистентная память
  ...
  12 ○ Практические рецепты и workflow

▸ another-series (пауза)
  "Другая серия"
  Прогресс: 0/5
```

Статусы: `✓` published, `◉` research_done, `○` planned

## Межстатейный контекст

Токен-эффективный подход — при написании статьи N в контекст попадают:

| Данные | Источник | Примерный объём |
|--------|----------|-----------------|
| Глоссарий | series.json | ~100 токенов |
| Саммари опубликованных | series.json | ~50 токенов × N статей |
| Карта ссылок для текущей | series.json | ~30 токенов |
| Ресёрч текущей статьи | research/article-NN.md | ~500-1000 токенов |

Итого для статьи 6 из 12: ~500 + 1000 = ~1500 токенов серийного контекста. Полный текст 5 статей был бы ~15000 токенов.

## Принципы

- blog-post не модифицируется
- Универсально для любой серии
- Всё в файлах, всё в git
- Human gates на ключевых точках
- YAGNI: начинаем с минимума, расширяем по необходимости
